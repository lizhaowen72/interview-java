### 3.事务隔离:为什么你改了我还看不见?
#### 1.什么是事务?
> 简单来说,事务就是要保证一组数据库操作,要么全部成功,要么全部失败.
> 在MySQl中,事务支持是在引擎层实现的.我们知道,MySQL是一个支持多引擎的系统,但不是所有的引擎都支持事务的.
> 比如MySQL原生的MyISAM引擎就不支持事务,这也是MyISAM被InnoDB取代的重要原因之一

#### 2.事务的四种特性
> ACID 原子性,一致性,隔离性,持久性

#### 3.SQL标准的事务隔离级别包括哪些?
> 读未提交RU,一个事务还没提交时,他做的变更就能被别的事务看到  
> 读提交RC,一个事务提交之后,它做的变更才会被其他事务看到  
> 可重复读RR,一个事务执行过程中看到的数据,总是跟这个事务在启动时看到的数据时一致的
> 串行化serializable,对于同一行记录,写会加锁,读会加锁,当出现读写锁冲突的时候,后访问的事务必须等前一个事务执行完成,才能继续执行

#### 4.什么时候需要可重复读的场景呢?
> 我们来看一个数据校对逻辑的案例。假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，
> 也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。

#### 5.事务隔离的实现,以可重复读为例说明

#### 6.什么时候删除回滚日志?
>  在不需要的时候才删除,也就是说系统会判断,当没有事务再需要用到这些回滚日志的时候,回滚日志会被删除.
>  什么时候才不需要了呢?就是当系统里没有比这个回滚日志更早的read-view的时候

#### 7.为什么建议尽量不要使用长事务?
>  1.长事务意味着系统里面会存在很老的事务视图.由于这些事务随时可能访问数据库里面的任何数据,所以这个事务提交之前,数据库里面他可能用到的回滚记录都必须
>  保留,这就会导致大量占用存储空间  
>  2.在MySQL5.5及以前的版本,回滚日志是跟数据字典一起放在ibdata文件里的,即使长事务最终提交,回滚段被清理,文件也不会变小
>  除了对回滚段的影响,长事务还占用锁资源,也可能拖垮整个库.

#### 8.事务的启动方式
> 1. 显示启动事务语句,begin or start
>    transaction,配套的提交语句时commit,回滚语句时rollback
> 2. set autocommit=0,这个命令会将这个线程的自动提交关掉,意味着如果你只执行一个select语句,这个事务就启动了,而且并不会自动提交.这个事务持续存在直到你主动执行commit
>    或者rollback语句,或者断开连接

#### 9.如何避免多一次交互的问题?
> 对于一个需要频繁使用事务的业务,第二种方式每个事务在开始时都不需要主动执行一次begin,减少了语句的交互次数,可以使用
> commit work and
> chain语法,表示提交事务并自动启动下一个事务,这样也省去了再次执行begin语句的开销.同时带来的好处是从程序开发的角度明确的知道每个语句是否处于事务中

#### 10.查询持续时间超过60s的事务?
> select * from information_schema.innodb_trx where
> TIME_TO_SEC(timediff(now(),trx_started))>60
