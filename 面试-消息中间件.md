1.面试官:你在系统里用过消息队列吗?
ans:用过的
2.面试官:那你说下你们在项目里是怎么用消息队列的?

3.面试官:那你们为什么使用消息队列啊?
业务场景,这个业务场景有什么技术挑战
消息队列常见的三种核心使用场景:解耦 异步 削峰
解耦:画图,假设A系统发送个数据到BCD三个系统,接口调用发送,那如故E系统也要这个数据?那如果C系统现在不需要了呢?A系统要时时刻刻
考虑BCDE四个系统如果挂了怎么办?要不要重新调用接口?

异步:降低延迟

削峰:每天0点到11点,A系统风平浪静,每秒并发请求数量是100个,结果每次一到11点到1点,每秒请求数达到1万,但是系统最大出力能力每秒钟
2000个,系统会被压垮.如果使用mq,可以将多余的消息暂时存起来,等到高峰期过后处理

4.面试官:那你说说用消息队列都有什么优点和缺点?
优点:在特殊场景下有其对应的好处,解耦 异步 削峰
缺点:
>1.系统可用性降低,mq一旦故障,订阅系统将无法消费到消息,进而导致整个系统崩溃
>2.系统复杂度提高,系统A本来给系统B发一条数据就可以了,结果因为系统A和MQ之间协调出现问题,系统A不小心将同一条数据发送了2次给系统B,
> 导致系统B内部插入了2条一模一样的数据
>3.一致性问题:A系统处理完了直接返回成功了,用户以为成功了,但是问题是,要是BCD三个系统那里,BC两个系统写库成功了,结果C系统写库失败了,
> 就会导致数据不一致问题

5.如何保证消息队列的高可用

6.如何处理消费过程中的重复消费
>1.消息重复的情况必然存在.这是因为在MQTT(消息队列遥测传输)协议中,给出了三种传递消息时能够提供的服务质量标准,这三种服务质量从低到高依次是
> At most once:至多一次.消息在传递时,最多会送达一次.换一个说法就是,没什么消息可靠性保证,允许丢消息.一般都是一些对消息可靠性要求不太高的
> 监控场景使用,比如每分钟上报一次机房温度数据,可以接受数据少量丢失
> At least once:至少一次.消息在传递时,至少会被送达一次.也就是说,不允许丢消息,但是允许有少量重复消息存在.
> Exactly once:恰好一次.消息在传递时,只会被送达一次,不允许丢失也不允许重复.这个是最高的等级.
> 这个服务质量标准不仅适用于MQTT,对所有的消息队列都是适用的.我们现在常用的绝大部分消息队列提供的服务质量都是At least once,包括
> RocketMQ RabbitMQ和kafka都是这样,也就是说很难保证消息不重复
> 2.解决消息重复
> a.用幂等性解决重复消息问题(一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同).举个例子:
> 在不考虑并发的情况下:"将账户的余额设置为100元",这是一个幂等操作.
> "将账户x的余额加100元",这个操作不是敏等的
> 如果系统消费消息的业务逻辑具备幂等性,那就不用担心消息重复的问题,因为同一条消息,消费一次和消费多次对系统的影响是完全一样的.
> 也就可以认为,消费多次等于消费一次.
> 从对系统的影响结果来说:At least once + 幂等消费 = Exactly once
> 那如何实现幂等操作呢?最好的方式就是从业务逻辑上入手,将消费的业务逻辑设计成具备幂等性的操作
> a1:利用数据库的唯一约束实现幂等.举个例子:"将账户x的余额增加100元",可以限定,对于每个转账单每个账户只可以执行一次变更操作.转账流水表:
> 转账单id,账户id,变更金额,转账单id和账户id创建联合索引(生产者只要保证，发出去的每条转账消息都有一个唯一的转账单ID，这个“转账单 ID”可以存在生产者的数据库中，也可以不存，看业务需求。只要这个转账单ID不重复就可以了，这个很容易做到，比如我们用MySQL的Sequence就可以生成。
消费者用这个转账单ID结合数据库（消费者的数据库，可以和生产者数据库不同）的唯一约束，就可以来实现消费幂等了。)这样对于相同的转账单id和账户id,表里至多只能存在一条记录
> a2:为更新的数据设置前置条件
> 给数据增加一个版本号属性,每次更新数据前,比较当前数据的版本号是否和消息中的版本号一致,如果不一致就拒绝更新数据,如果一致,则更新数据的同时将版本号+1,一样可以实现幂等更新
> a3:记录并检查操作
> 记录并检查操作,也称为"Token机制或者GUID(全局唯一id)机制",实现的思路特别简单:在执行数据更新操作之前,先检查一下是否执行过这个更新操作.
> 具体的实现方法时,在发送消息时,给每条消息指定一个全局唯一的id,消费时,先根据这个id检查这条消息是否有被消费过,如果没有消费过,才更新数据,然后将消费状态置为已消费.
> 在分布式系统中,这个方法其实是非常难以实现的,涉及到分布式事务和分布式锁

7.为什么大部分消息队列都选择只提供 At least once 的服务质量，而不是级别更高的 Exactly once 呢？
我觉得最重要的原因是消息队列即使做到了Exactly once级别，consumer也还是要做幂等。因为在consumer从消息队列取消息这里，如果consumer消费成功，  
但是ack失败，consumer还是会取到重复的消息，所以消息队列花大力气做成Exactly once并不能解决业务侧消息重复的问题。

8.如何确保消息不会丢失?
我们可以消息队列的有序性来验证是否有消息丢失.原理非常简单,在Producer端,我们给每个发出的消息附加一个连续递增的序号,  
然后在Consumer端来检查这个序号的连续性.
一条消息从生产到消费完成这个过程,可以划分为三个阶段
在生产阶段:你需要捕获消息发送的错误,并重发消息
在存储阶段:你可以通过配置刷盘和复制相关的参数,让消息写入到多个副本的磁盘上,来确保消息不会因为某个broker宕机,或者磁盘
损坏而丢失.
在消费阶段:你需要在处理完全部消费业务逻辑之后,再发送消费确认

9.消息积压了该如何处理?
>a.在设计系统的时候,一定要保证消费端的消费性能要高于生产端的发送性能,这样的系统才能健康的持续运行
>b.水平扩容,增加消费端的并发数来提升总体的消费性能.在扩容Consumer的实例数量的同时,必须同步扩容
> 主题中的分区数量,确保Consumer的实例数和分区数量是相等的.
> 一、如何预防消息积压？
1、发送端提高并发及批量大小；
2、消费端增加实例且同步扩容分区；

二、如何处理消息积压？
1、消费端扩容；
2、服务降级；
3、异常监控。

10.如何保证消息的顺序性?
>RocketMQ采用了局部顺序一致性的机制,实现单个队列中消息严格有序,也就是说,如果想要保证顺序消费,必须将一组消息发送到同一个队列找中,然后再由
> 消费者进行顺序消费
> RocketMQ推荐的顺序消费解决方案是:按照业务划分不同的队列,然后将需要顺序消费的消息发往统一队列中即可.

11.如何利用事务消息实现分布式事务?
消息队列中的事务,主要解决的是消息生产者和消息消费者的数据一致性问题.
一致性，是指这些数据在事务执行完成这个时间点之前，读到的一定是更新前的数据，之后读到的一定是更新后的数据，不应该存在一个时刻，让用户读到更新过程中的数据。
分布式事务就是要在分布式系统中的实现事务。在分布式系统中，在保证可用性和不严重牺牲性能的前提下，光是要实现数据的一致性就已经非常困难了，所以出现了很多“  
残血版”的一致性，比如顺序一致性、最终一致性等等。显然实现严格的分布式事务是更加不可能完成的任务。所以，目前大家所说的分布式事务，  
更多情况下，是在分布式系统中事务的不完整实现。在不同的应用场景中，有不同的实现，目的都是通过一些妥协来解决实际问题。在实际应用中，比较常见的分布式事务实现有  
 2PC（Two-phase Commit，也叫二阶段提交）、TCC(Try-Confirm-Cancel) 和事务消息。每一种实现都有其特定的使用场景，也有各自的问题，都不是完美的解决方案
事务消息适用的场景主要是那些需要异步更新数据，并且对数据实时性要求不太高的场景。比如我们在开始时提到的那个例子，在创建订单后，如果出现短暂的几秒，购物车里的商  
品没有被及时清空，也不是完全不可接受的，只要最终购物车的数据和订单数据保持一致就可以了。

12.如果让你写一个消息队列，该如何进行架构设计呢？说一下思路
1)首先这个mq得支持可伸缩性
2）其次考虑mq的数据落盘 顺序写
3）其次考虑mq的可用性？ 多副本 -》Leader & follower -》broker挂了重新选举leader
4）能不能支持数据不丢失？ 保证队列中数据有序性
5）数据一致性 事务消息实现分布式事务，卡夫卡报错，RocketMQ 反查机制




1.发送Half消息
2.Half消息发送成功
3.执行本地事务
4.提交或回滚事务
5.网络异常，Broker没有收到commit or rollback，回查本地事务状态
6.检查本地事务状态
7.根据本地事务状态执行commit or rollback
8.根据 4 或 7 投递消息到MQ订阅方，或者取消不投递



5.面试官:Kafka activemq rabbitmq rocketmq都有什么区别?
选择中间件的考量维度:可靠性,性能,可运维性,可扩展性,是否开源以及社区活跃度
> rabbitmq
> 优点:轻量,迅捷,容易部署和使用,拥有灵活的路由配置
> 缺点:性能和吞吐量较差,基于erlang语言开发,不易进行二次开发
> rocketmq
> 优点:性能好,稳定可靠,有活跃的中文社区,特点响应快
> 缺点:兼容性较差,但随着影响力的扩大,该问题会改善
> kafka
> 优点:拥有强大的性能及吞吐量,兼容性好
> 缺点:由于攒一波再处理导致延迟比较高

6.消息模型:主题和队列有什么却别?
> 最大的区别:一份消息数据能不能被消费多次的问题
> 实际上,在这种发布订阅模型中,如果只有一个订阅者,那它和队列模型就基本是一样的了.也就是说,发布订阅模型在功能层面上是可以
> 兼容队列模型的


7.如何利用事务消息实现分布式事务?
消息队列中的"事务",主要解决的是消息生产者和消息消费者的数据一致性问题