当创建逻辑比较复杂,是一个大工程的时候,我们考虑使用工厂模式,封装对象的创建过程,将对象的创建和使用相互分离.
何为创建逻辑比较复杂呢?我总结了下面两种情况:
> 第一种情况:类似规则配置解析的例子,代码中存在if-else分支判断,动态的根据不同的类型创建不同的对象.针对
> 这种情况,我们就考虑使用工厂模式,将这一大块if-else创建对象的代码抽离出来,放到工厂类中
>
> 第二种情况:尽管我们不需要根据不同的类型创建不同的对象,但是,单个对象本身的创建过程比较复杂,比如前面提到要组合
> 其他类对象,做各种初始化操作.在这种情况下,我们可以考虑使用工厂模式,将对象的创建过程封装到工厂类中
>
> 对于第一种情况,当每个对象的创建逻辑都比较简单的时候,我推荐使用简单工厂模式,将多个对象的创建逻辑放到一个工厂类中
> 当每个对象的创建逻辑都比较复杂的时候,为了避免设计一个过于庞大的简单工厂类,我推荐使用工厂方法模式,将创建逻辑拆分的
> 更细,每个对象的创建逻辑独立到各自的工厂类中.同理,对于第二种情况,因为单个对象本身的创建逻辑就比较复杂,所以我推荐使用]
> 使用工厂方法模式
>
> 如果创建对象的逻辑并不复杂,那么我们就直接通过new来创建对象就可以了,不需要使用工厂模式
>
> 判断是否要使用工厂模式的最本质的四个标准  
> 1.封装变化:创建逻辑有可能变化,封装成工厂类之后,创建逻辑的变更对调用者透明
> 2.代码复用:创建代码抽离到独立的工厂类之后可以复用
> 3.隔离复杂性:封装复杂的创建逻辑,调用者无需了解如何创建对象
> 4.控制复杂度:将创建代码抽离出来,让原本的函数或者类职责更单一,代码更简洁
>
> 网友评论
> 复杂度无法被消除,只能被转移
> 不用工厂模式,if-else逻辑 创建逻辑和业务代码耦合在一起
> 简单工厂是将不同的创建逻辑放到一个工厂类中,if-else逻辑在这个工厂类中
> 工厂方法时将不同逻辑放到不同工厂类中,先用一个工厂类的工厂a来得到某个类型的工厂b,再用这个工厂b来创建,if-else逻辑在工厂类的工厂中
> 通俗的比喻就跟整理衣服差不多.衣服少的时候,都放在一起,多的时候,按照一定规则分一下,整理一下
>
