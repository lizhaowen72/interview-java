下面的代码用 synchronized 修饰代码块来尝试解决并发问题，你觉得这个使用方式正确吗？有哪些问题呢？能解决可见性和原子性问题吗？
    public class SafeCalc {
        long value = 0L;
        long get(){
            synchronized (new Object()){
                return value;
            }
        }
        void addOne(){
            synchronized (new Object()){
                value+=1;
            }
        }
    }

加锁的本质就是在锁对象的对象头中写入当前线程id,但是new Object()每次在内存中都是新对象,所以加锁无效
经过jvm逃逸分析的优化后,这个sync代码直接回被优化调,所以在运行时该代码块是无锁的

使用锁保护资源时，对资源的所有操作应该使用同一个锁，这样才能起到保护的作用。
课后题中每个线程对资源的操作都是用的是各自的锁，不存在互斥和竞争的情况。
这就相当于有一个房间，每个人过来都安装一个门，每个人都有自己门的钥匙，大家都可以随意出入这个房间。
由于每个线程都可以随时进入方法，所以存在原子性问题；
但是因为每次都有加锁和解锁的操作，unlock操作会使其他缓存的变量失效，需要重新从主内存中加载变量的值，所以可以解决可见性问题。