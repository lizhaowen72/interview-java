设计模式
一.创建型设计模式

    创建型设计模式包括:单例模式 工厂模式 建造者模式 原型模型,它主要解决对象的创建问题,封装复杂的创建过程,解耦对象的创建代码和使用代码.  
    1.单例模式
    单例模式用来创建全局唯一的对象.一个类只允许创建一个对象(或者叫实例),那这个类就是一个单例类,这种设计模式叫做单例模式.单例有几种经典的实现
    方式:饿汉式 懒汉式 双重检测 静态内部类 枚举
    
    2.工厂模式包括简单工厂 工厂方法 抽象工厂这3种细分模式.其中,简单工厂和工厂方法比较常用,抽象工厂的应用场景比较特殊,很少用到
    工厂模式用来创建不同但是相关类型的对象(继承同一父类或者接口的一组来自类),由给定的参数来决定哪种类型的对象.实际上,如果创建对象的逻辑
    并不复杂,那我们直接通过new来创建对象就可以了,不需要使用工厂模式.当创建逻辑比较复杂,是一个大工程的时候,我们就考虑使用工厂模式,封装对象的
    创建过程,将对象的创建和使用分离.
    当每个对象的创建逻辑都比较简单的时候,我推荐使用简单工厂模式,将多个对象的创建逻辑放到一个工厂类中.当每个对象的创建逻辑都比较复杂的时候,为了
    避免设计一个过于庞大的工厂类,我推荐使用工厂方法模式,将创建逻辑拆分的更细,每个对象的创建逻辑独立到各自的工厂类中.
    详细点说,工厂模式的左右有下面4个,这也是判断要不要使用工厂模式最本质的参考标准.
        封装变化:创建逻辑有可能变化,封装成工厂类之后,创建逻辑的变更对调用者透明
        代码复用:创建代码抽离到独立的工厂类之后可以复用
        隔离复杂性:封装复杂的创建逻辑,调用者无需了解如何创建对象
        控制复杂度:将创建代码抽离出来,让原本的函数或类职责更单一,代码更简洁  
    工厂模式一个非常经典的应用场景:依赖注入框架,比如Spring IOC,它用来集中创建 组装 管理对象,跟具体业务代码解耦,让程序员聚焦在业务代码的开发商.
    
    3.建造者模式
         建造者模式用来创建复杂对象,可以通过设置不同的可选参数,定制化的创建不同的对象.建造者模式的原理和实现比较简单,重点是掌握应用场景,避免
     过度使用.
        如果一个类中有很多属性,为了避免构造函数的参数列表过长,影响代码的可读性和易用性,我们可以通过构造函数配合set()方法来解决.但是如果存在下面情况
    中的任意一种,我们就要考虑使用建造者模式了
        a.我们把类的必填属性放到构造函数中,强制创建对象的时候就设置.如果必填的属性有很多,把这些必填属性都放到构造函数中设置,那构造函数就又会出现
    参数列表很长的问题.如果我们把必填属性通过set()方法设置,那校验这些必填属性是否已经填写的逻辑就无处安放了
        b.如果类的属性之间有一定的依赖关系或者约束条件,我们继续使用构造函数配合set()方法的设计思路,那这些依赖关系或约束条件的校验逻辑就无处安放了.
        c.如果我们希望创建不可变对象,也就是说,对象在创建好之后,就不能再修改内部的属性值,要实现这个功能,我们就不能再类中暴露set()方法.构造函数配合set()
    方法来设置属性值的方式就不适用了.
    
    4.原型模式
        如果对象的创建成本比较大,而同一个类的不同对象之间差别不大(大部分字段都相同),在这种情况下,我们可以利用对已有对象(原型)进行复制(或者叫拷贝)的方式,
    来创建对象,以达到节省创建时间的目的.这种基于原型来创建对象的方式叫做原型模式
        原型模式有两种实现方法,深拷贝和浅拷贝.浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址,不会递归的复制引用对象,以及引用对象的引用对象,而
    深拷贝得到的是一份完完全全独立的对象.索引,深拷贝比起浅拷贝来说,更加耗时,更加耗内存空间
        如果要拷贝的对象是不可变对象,浅拷贝共享不可变对象是没有问题,但对于可变对象来说,浅拷贝得到的对象和原始对象会共享部分数据,就有可能出现数据被修改的风险,
    也就变得复杂多了.操作非常耗时的情况下,我们比较推荐使用浅拷贝,否则,没有充分的理由,不要为了一点点的性能提升而使用浅拷贝.
二.结构性设计模式
结构型模式主要总结了一些类或对象组合在一起的经典结构,这些经典的结构可以解决特定应用场景的问题.结构型模式包括:代理模式 桥接模式
装饰器模式 适配器模式 门面模式 组合模式 享元模式

    1.代理模式
        它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能
        代理模式在不改变原始类接口的条件下,为原始类定义一个代理类,主要目的是控制访问,而非加强功能,这是它跟装饰器模式最大
    的不同.一般情况下,我们让代理类和原始类实现同样的接口,但是原始类并没有定义接口,并且原始类并不是我们开发和维护的.在这种
    情况,我们可以通过让代理类继承原始类的方法来实现代理模式
        静态代理需要针对每个类都创建一个代理类,并且每个代理类中的代码都有点像模板模式的"重复"代码,增加了维护成本和开发成
    本.对于静态代理存在的问题,我们可以通过动态代理来解决.我们不事先为每个原始类编写代理类,而是在运行时动态的创建原始类对
    应的代理类,然后再系统中用代理类替换掉原始类.
        代理模式常用在业务系统中开发一些非公能性需求,比如:监控 统计 鉴权 限流 事务 幂等 日志.我们将这些附加功能与业务功
    能解耦,放到代理类统一处理,让程序员只需要关注业务方面的开发;

    2.桥接模式
        gof定义:将抽象和实现解耦，让它们可以独立变化
        桥接模式有两种理解方式.第一种理解方式是"将抽象和实现解耦,让他们能独立开发".这种理解方式比较特别,应用场景也不多. 
    另一种理解方式更加简单,等同于"组合优于继承"设计原则,这种理解方式更加通用,应用场景比较多.不管是哪种理解方式,他们的代码
    结构都是相同的,都是一种类之间的组合关系.
        对于第一种理解方式,定义中的抽象,指的并非抽象类或接口,而是被抽象出来的一套类库,它只包含骨架代码,真正的业务逻辑需要
    委派给定义中的"实现"来完成,而定义中的"实现",也并非"接口的实现类",而是一套独立的类库.抽象和实现独立开发,通过对象之间的组合
    关系组装在一起
    
    3.装饰器模式
        装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要
    的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类
    需要跟原始类继承相同的抽象类或者接口                      

    4.适配器模式
        代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容
    的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配
    器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现
    
    5.门面模式
        gof定义:门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。
    门面模式原理和实现都非常简单,应用场景比较明确.它通过封装细粒度的接口,提供组合各个细粒度接口的高层次接口,来提高接口的易用性,
    或者解决性能 分布式事务等问题
    
    6.组合模式
        主要是用来处理树形结构数据.正因为其应用场景的特殊性,数据必须能表示成树形结构,这也导致了这种模式在实际的项目开发中并不
    那么常用.但是一旦数据满足树形结构,应用这种模式就能发挥很大的作用,能让代码变得非常简洁
    
    7.享元模式
        所谓享元,顾名思义就是被共享的单元.享元模式的意图是复用对象.节省内存,前提是享元对象是不可变对象.
    具体来讲,当一个系统中存在大量重复对象的时候,我们就可以利用享元模式,将对象设计成享元,在内存中只保留一份实例,供多处代码引用,
    这样可以减少内存中对象的数量,以起到节省内存的目的.实际上,不仅仅相同对象可以设计成享元,对于相似对象,我们也可以将这些对象中
    相同的部分(字段),提取出来设计成享元,让这些大量相似对象引用这些享元.        
三.行为型设计模式  
行为型设计模式主要解决的就是类或对象之间的交互问题

    1.观察者模式
    gof定义:在对象之间定义一个一对多的依赖,当一个对象状态改变的时候,所有依赖的对象都会自动收到通知.
        观察者模式将观察者和被观察者代码解耦.
    不同的应用场景和需求下,这个模式也有截然不同的实现方式:有同步阻塞的实现方式,也有异步非阻塞的实现方式;有进程内的实现方式,也
    跨进程的实现方式.同步阻塞式最经典的实现方式,主要是为了代码解耦;异步非阻塞除了能实现代码解耦之外,还能提高代码的执行效率;进
    程间的观察者模式解耦更加彻底,一般是基于消息队列来实现,用来实现不同进程间的被观察者和观察者之间的交互.
        观察者模式的应用场景非常广泛,小到代码层面的解耦,大到架构层面的系统解耦,都有这种模式的影子,比如邮件订阅 RSS Feeds,本
    质上都是观察者模式
    
    2.模板模式
        模板方法模式在一个方法中定义一个算法骨架,并将某些步骤推迟到子类中实现.模板方法模式可以让子类在不改变算法整体结构的情
    况下,重新定义算法中的某些步骤.这里的算法,可以理解为广义上的业务逻辑,并不特指数据结构和算法中的算法.这里的算法骨架就是模板,
    包含算法骨架的方法就是模板方法,这也是模板方法模式名字的由来.
        模板模式有两大作用:复用和扩展.其中复用指的是,所有的子类可以复用父类中提供的模板方法的代码.扩展是指,框架通过模板模式
    提供功能扩展点,让框架用户可以在不修改框架源码的情况下,基于扩展点定制化框架的功能.
    
    3.策略模式
        策略模式定义一族算法类,将每个算法分别封装起来,让他们可以互相替换.策略模式可以使得算法的变化独立于使用他们的客户端(这里
    的客户端代指使用算法的代码).策略模式用来解耦策略的定义 创建 使用
        策略类的定义比较简单,包含一个策略接口和一组实现这个接口的策略类.
        策略的创建由工厂类来完成,封装策略创建的细节.
        策略模式包含一组策略可选,客户端代码选择使用哪个策略,有两种确定方法:编译时静态确定和运行时动态确定.其中,"运行时动态确
    定"才是策略模式最典型的应用场景.
        在实际的项目开发中,策略模式也比较常用.最常见的应用场景是,利用它来避免冗长的if else 或switch分支判断.不过它的作用还
    不止如此.它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的
    复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，
    最小化、集中化代码改动，减少引入 bug 的风险。                    
