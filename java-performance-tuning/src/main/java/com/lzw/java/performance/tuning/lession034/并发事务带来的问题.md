### 1.并发事务带来的问题
     1).数据丢失
     2).脏读
     3).不可重复读
     4).幻读

### 2.事务隔离解决并发问题
    InnoDB实现了两种类型的锁机制:共享锁(S)和排他锁(X).
    共享锁允许一个事务读数据,不允许修改数据,如果其他事务要再对该行加锁,只能加共享锁
    排他锁是修改数据时加的锁,可以读取和修改数据,一旦一个事务对该行数据加锁,其他事务将不能再对该行数据加任务锁
    
    未提交读(RU):在事务A读取数据时,事务B读取数据加了共享锁,修改数据时加了排他锁,这种隔离级别,会导致脏读 不可重复读以及幻读
    已提交读(RC):在事务A读取数据时增加了共享锁,一旦读取,立即释放锁,事务B读取修改数据时增加了行级排他锁,直到事务结束才释放锁
    可重复读(RR):在事务A读取数据时增加了共享锁,事务结束,才释放锁,事务B读取修改数据时增加了行级排他锁,直到事务结束才释放锁.
    可序列化(Serializable):在事务A读取数据时增加了共享锁,事务结束,才释放锁,事务B读取修改时增加了表级排他锁,直到事务结束才释放锁
    
    MVCC 对普通的 Select 不加锁，如果读取的数据正在执行 Delete 或 Update 操作，这时读取操作不会等待排它锁的释放，而是直接利用 
    MVCC 读取该行的数据快照（数据快照是指在该行的之前版本的数据，而数据快照的版本是基于 undo 实现的，undo 是用来做事务回滚的，记录了回滚的不同版本的行记录）。MVCC 避免了对数据重复加锁的过程，大大提高了读操作的性能。

### 3.锁具体实现算法
    InnoDB既实现了行锁,也实现了表锁.行锁是通过索引实现的,如果不通过索引条件检索数据,那么InnoDB将对表中所有的记录进行加锁,其实就是升级为表锁了
    
    行锁的具体实现算法有三种:record lock 、gap lock 以及 next-key lock。
    record lock 是专门对索引项加锁
    gap lock是对索引项之间的间隙加锁
    next-key lock 对索引项以及之间的间隙加锁

###  4.优化高并发事务
    1.结合业务场景,使用低级别事务隔离
    用户登录修改个人信息,允许该业务使用最低隔离级别
    账户中的余额或者积分的消费,应该选择RR级别来保证一个客户端在对账户进行消费,其他客户端不可能对该账户同时进行消费
    
    2.避免行锁升级为表锁
    在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。
    我们知道，表锁是会严重影响到整张表的操作性能的，所以我们应该避免他。
    
    3.控制事务的大小,减少锁定的资源量和锁定的时间长度

### 用户抢购商品
|执行顺序1|执行顺序2|
|:---|:---|
|1.开启事务|1.开启事务|
|2.查询库存,判断库存是否满足|2.查询库存,判断库存是否满足|
|3.新建订单|3.扣除库存|
|4.扣除库存|4.新建订单|
|5.提交或者回滚|5.提交或者回滚|

### 总结
    其实MySQL的并发事务调优和java的多线程编程调优非常类似,都是可以通过减小锁粒度和减少多的持有时间进行调优.
    在Mysql的并发事务调优中,应尽量在可以使用低事务隔离级别的业务场景中,避免使用高事务隔离级别
    
    在功能业务开发时，开发人员往往会为了追求开发速度，习惯使用默认的参数设置来实现业务功能。例如，在 service 方法中，你可能习惯默认使用 transaction，很少再手动变更事务隔离级别。但要知道，
    transaction 默认是 RR 事务隔离级别，在某些业务场景下，可能并不合适。因此，我们还是要结合具体的业务场景，进行考虑。

### 思考题
    InnoDB是如何实现原子性 一致性 持久性的吗?
    binlog+ redo log 两阶段提交保证持久性
    事务的回滚机制 保证原子性(要么全部提交成功 要么回滚)
    undo log+mvcc 保证一致性(事务开始和结束的过程不会有其他事务看到,为了并发可以适当破坏一致性)    